FMaterialRefractionData GetMaterialRefraction(FPixelMaterialInputs PixelMaterialInputs)
{
	FMaterialRefractionData Data;
	Data.Data					= PixelMaterialInputs.Refraction.xy;
	Data.RefractionDepthBias	= PixelMaterialInputs.Refraction.z;
	return Data;
}

vec2 GetMaterialRefraction2DOffset(in FMaterialRefractionData RefractionData)
{
#if REFRACTION_USE_2D_OFFSET
	return RefractionData.Data.xy;
#else
	return vec2(0.0f, 0.0f);
#endif
}


vec2 ComputeBufferUVDistortion(
	in FMaterialPixelParameters MaterialParameters, in FPixelMaterialInputs PixelMaterialInputs, in ViewState ResolvedView,
	in half3 WorldNormal, in float InMaterialIOR,
	in float4 DistortionParameters, in vec2 ScreenUV, in FMaterialRefractionData RefractionData, in bool TryToClip, in uint EyeIndex)
{
	half3 ViewNormal = normalize(TransformWorldVectorToView(WorldNormal));

// #if REFRACTION_USE_PIXEL_NORMAL_OFFSET
// 	half3 ViewVertexNormal = TransformTangentVectorToView(MaterialParameters, float3(0, 0, 1));
// 	// Treat refraction of 1 as no refraction, to be consistent with IOR mode
// 	vec2 ViewportUVDistortion = (ViewVertexNormal.xy - ViewNormal.xy) * (GetMaterialRefractionPixelNormalStrength(RefractionData) - 1);

// #elif REFRACTION_USE_INDEX_OF_REFRACTION
	// we assume the camera is in air
	float AirIOR = 1.0f;
	float MaterialIOR = InMaterialIOR;
	vec2 ViewportUVDistortion = ViewNormal.xy * (MaterialIOR - AirIOR);


	vec2 BufferUVDistortion = ViewportUVDistortion * ResolvedView.ViewSizeAndInvSize.xy * ResolvedView.BufferSizeAndInvSize.zw;

	// Clip if the distortion distance (squared) is too small to be noticed.
	// This will result in a less expensive apply pass since the clipped pixels won't set stencil to pass.
	// We only clip if the distortion is less than the size of a pixel of the unscaled viewport, i.e. dynamic resolution = 100%, to ensure a good reconstruction.
	const vec2 FullResolutionDistortionPixelSize = ResolvedView.BufferSizeAndInvSize.zw;
	if (TryToClip && 
		all(abs(BufferUVDistortion) < FullResolutionDistortionPixelSize))
	{
		clip(-1.0f);
	}

	float InvTanHalfFov = DistortionParameters.x;
	float Ratio = DistortionParameters.y;

	// InvTanHalfFov only apply a correction for the distortion to be the same in screen space space whatever the FoV is (to make it consistent accross player setup).
	// However without taking depth into account, the distortion will actually be stronger the further away the camera is from the distortion surface.
	// So when zoomed-in the distortion will be higher than expected.
	// To fix this, a scale of 100/SurfaceDepth would be a good approximation to make the distortion properly scaled when the surface is zoomed in and/or further away (with distortion authored at 1meter being the reference strength)

	// Fix for Fov and aspect.
	vec2 FovFix = vec2(InvTanHalfFov, Ratio*InvTanHalfFov);
	//A fudge factor scale to bring values close to what they would have been under usual circumstances prior to this change.
	const float OffsetFudgeFactor = 0.00023;
	BufferUVDistortion *= DistortionParameters.zw * vec2(OffsetFudgeFactor, -OffsetFudgeFactor) * FovFix;

	return BufferUVDistortion;
}