#version 450

#extension GL_EXT_mesh_shader : require
#extension GL_EXT_shader_8bit_storage: require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require

#define MESHLETS_PER_TASK_WORKGROUP 32
#define TASK_WORKGROUP_SIZE 32
#define MESH_WORKGROUP_SIZE 64
#define MESHLETS_PER_MESH_WORKGROUP 1
#define MAX_PRIMITIVES_PER_MESHLET 124 * MESHLETS_PER_MESH_WORKGROUP
#define MAX_VERTICES_PER_MESHLET 64 * MESHLETS_PER_MESH_WORKGROUP

const uint MESHLETS_PER_TASK_INVOCATION = (MESHLETS_PER_TASK_WORKGROUP + TASK_WORKGROUP_SIZE - 1) / TASK_WORKGROUP_SIZE;
const uint PRIMITIVE_ITERATION_COUNT = (MAX_PRIMITIVES_PER_MESHLET + MESH_WORKGROUP_SIZE - 1) / MESH_WORKGROUP_SIZE;
const uint VERTEX_ITERATION_COUNT = (MAX_VERTICES_PER_MESHLET + MESH_WORKGROUP_SIZE - 1) / MESH_WORKGROUP_SIZE;

struct Meshlet
{
	uint vertexOffset;
	uint vertexCount;
	uint triangleOffset;
	uint triangleCount;
};
struct VBO
{
	vec3 position;
	vec3 normal;
};
struct Task
{
	uint baseMeshletId;
	uint8_t meshletIdOffset[MESHLETS_PER_TASK_WORKGROUP];
};

taskPayloadSharedEXT Task IN;
layout(local_size_x = MESH_WORKGROUP_SIZE) in;
layout(triangles, max_vertices = MAX_VERTICES_PER_MESHLET, max_primitives = MAX_PRIMITIVES_PER_MESHLET) out;
layout(location = 0) out PerVertexData
{
	vec3 colorRGB;
} v_out[];

layout(set = 0, binding = 0) uniform CameraUBO {
	mat4 view;
	mat4 proj;
	vec4 eye;
}ubo;
layout(set = 1, binding = 0) readonly buffer Meshlets {Meshlet meshlets[];};
layout(set = 1, binding = 1) readonly buffer MeshletVertices {uint meshletVertices[];};
layout(set = 1, binding = 2) readonly buffer MeshletTriangles {uint8_t meshletTriangles[];};
layout(set = 1, binding = 3) readonly buffer VertexBuffer {VBO vertices[];};
layout(set = 1, binding = 4) uniform ModelUBO{
	mat4 model;
	mat4 inverseTransposeModel;
	float scaleFactor;
	uint meshletCount;
}modelUBO;

// Returns the meshlet ID for the current mesh shader workgroup of the current invocation
uint getMeshletID(uint iteration)
{
	uint workGroupID = gl_WorkGroupID.x;
	return IN.baseMeshletId + IN.meshletIdOffset[workGroupID * MESHLETS_PER_MESH_WORKGROUP + iteration];
}

// Returns the local invocation ID within the workgroup
uint getLocalInvocationID()
{
	return gl_LocalInvocationID.x;
}

VBO getVertex(uint index)
{
	return vertices[index];
}

vec3 randomColor(uint seed) {
    // Normalize the seed (uint8_t is between 0-255)
    float base = float(seed & 0xFFu) / 255.0;

    // Generate pseudo-random RGB values based on the seed
    float r = fract(sin(base * 12.9898) * 43758.5453) + 0.02;
    float g = fract(sin(base * 78.233) * 43758.5453) + 0.02;
    float b = fract(sin(base * 45.164) * 43758.5453) + 0.02;

    return vec3(r, g, b); // Return the generated color
}

void GetTriangleIndex(in Meshlet _meshlet, in uint _primitiveIndex, out uvec3 _meshletIndices)
{
	uint begin = _meshlet.triangleOffset + _primitiveIndex * 3;
	_meshletIndices = uvec3(
		meshletTriangles[begin + 0],
		meshletTriangles[begin + 1],
		meshletTriangles[begin + 2]
	);
}

uint GetMeshVertexIndex(in Meshlet _meshlet, in uint _meshletIndex)
{
	return meshletVertices[_meshlet.vertexOffset + _meshletIndex];
}

void main()
{
	Meshlet vecMeshlets[MESHLETS_PER_MESH_WORKGROUP]; // all meshlets processed by parent workgroup
	uint uWorkGroupOutputVertexCount = 0u;	// number of vertices processed by parent workgroup
	uint uWorkGroupOutputPrimitiveCount = 0u; // number of primitives/triangles processed by parent workgroup
	uint uWorkGroupMeshlet = 0u; // number of meshlets processed by parent workgroup
	const uint uThreadPrimitiveOffset = getLocalInvocationID() * PRIMITIVE_ITERATION_COUNT; // each thread only process partial of the whole meshlet
	const uint uThreadVertexOffset    = getLocalInvocationID() * VERTEX_ITERATION_COUNT; // each thread only process partial of the whole meshlet
	
	for (uint i = 0u; i < MESHLETS_PER_MESH_WORKGROUP; ++i)
	{
		uint uMeshletID = getMeshletID(i);
		if (uMeshletID >= modelUBO.meshletCount)
		{
			break;
		}
		vecMeshlets[i]             = meshlets[uMeshletID];
		uWorkGroupOutputVertexCount    += vecMeshlets[i].vertexCount;
		uWorkGroupOutputPrimitiveCount += vecMeshlets[i].triangleCount;
		++uWorkGroupMeshlet;
	}
	// Should be the same for all mesh shader invocations in the same workgroup
	// All output variables must only be accessed after SetMeshOutputsEXT
    // has been called in the current invocation group. Only through the use of this
    // function primitives can be emitted from the group. In contrast to other
    // shaders, mesh shaders do not permit read access on output variables and
    // doing so results in undefined behavior.
	SetMeshOutputsEXT(uWorkGroupOutputVertexCount, uWorkGroupOutputPrimitiveCount);
	
	// Emit meshlet vertices and triangles
	uint uPreviousMeshletsVertCount = 0u; 	// for the case where we process more than one meshlet 
											// in a work group, ignore it if we only have one 
											// meshlet in each workgroup
	uint uPreviousMeshletsPrimitiveCount = 0u; 	// for the case where we process more than one meshlet 
												// in a work group, ignore it if we only have one meshlet 
												// in each workgroup
	for (uint i = 0u; i < uWorkGroupMeshlet; ++i)
	{
		// each mesh shader invocation doesn't process a complete meshlet, 
		// but processes only part of the meshlet owned by the same mesh workgroup
		// it's the mesh workgroup that processes complete meshlets
		const vec3 color = randomColor(getMeshletID(i));
		const uint uMeshletVertexCount = vecMeshlets[i].vertexCount;
		const uint uMeshletPrimitiveCount = vecMeshlets[i].triangleCount;

		for (uint j = 0u; j < VERTEX_ITERATION_COUNT; ++j)
		{
			uint uMeshletVertexIndex = uThreadVertexOffset + j; // the index of the vertex in the meshlet
			uint uMeshVertexIndex;
			
			// prevent out of bounds access
			if (uMeshletVertexIndex >= uMeshletVertexCount) 
				break; 
			
			uMeshVertexIndex = GetMeshVertexIndex(vecMeshlets[i], uMeshletVertexIndex);
			
			VBO vertex = getVertex(uMeshVertexIndex);
			gl_MeshVerticesEXT[uMeshletVertexIndex + uPreviousMeshletsVertCount].gl_Position = ubo.proj * ubo.view * modelUBO.model * vec4(vertex.position, 1.0);
			v_out[uMeshletVertexIndex + uPreviousMeshletsVertCount].colorRGB = normalize(modelUBO.inverseTransposeModel * vec4(vertex.normal, 0)).xyz * 0.5 + 0.5;
		}

		for (uint j = 0u; j < PRIMITIVE_ITERATION_COUNT; ++j)
		{
			uint uMeshletPrimitiveIndex = uThreadPrimitiveOffset + j; // the index of the primitive in current meshlet
			uvec3 u3MeshletTriangle;

			// prevent out of bounds access
			if (uMeshletPrimitiveIndex >= uMeshletPrimitiveCount) 
				break;
			
			GetTriangleIndex(vecMeshlets[i], uMeshletPrimitiveIndex, u3MeshletTriangle);
			
			// indices of vertices emit by gl_MeshVerticesEXT of this workgroup
			gl_PrimitiveTriangleIndicesEXT[uMeshletPrimitiveIndex + uPreviousMeshletsPrimitiveCount] = 
				u3MeshletTriangle + 
				uvec3(uPreviousMeshletsVertCount,uPreviousMeshletsVertCount,uPreviousMeshletsVertCount);
		}

	 	uPreviousMeshletsVertCount += uMeshletVertexCount;
		uPreviousMeshletsPrimitiveCount += uMeshletPrimitiveCount;
	}
}