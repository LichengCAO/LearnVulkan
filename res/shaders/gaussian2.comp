#version 450
#extension GL_EXT_nonuniform_qualifier : require
layout(set = 0, binding = 0) uniform sampler2D imgInput;
layout(set = 0, binding = 1, rgba32f) uniform writeonly image2D imgOutput;
layout(set = 0, binding = 2) uniform ViewportInformation
{
    ivec4 extent; // width, height, width * height
} viewportInfo;
layout(set = 0, binding = 3) uniform GaussianBlurInformation
{
    uint blurRad;
} blurInfo;
layout(set = 0, binding = 4) uniform GaussianKernel
{
    float kernels[16];
} gaussianKernels[];

// code from https://www.shadertoy.com/view/ctcBWM
void passX()
{
    uint index = gl_GlobalInvocationID.x; 
    if (index >= viewportInfo.extent.z) return;
    vec2 coord = vec2(index % viewportInfo.extent.x, index / viewportInfo.extent.x);
    vec2 resolution = viewportInfo.extent.xy;
    vec2 uv = coord/resolution;
    vec2 fragSize = vec2(1)/resolution;
    
    vec3 col = texture(imgInput, uv).rgb  * gaussianKernels[0].kernels[0]; // center pixel
    for(int i = 1; i < blurInfo.blurRad; ++i)
    {
        int x = i / 16;
        int y = i % 16;
        col += texture(imgInput, uv + vec2(fragSize.x * float(i), 0.0)).rgb * (gaussianKernels[x].kernels[y]);
        col += texture(imgInput, uv - vec2(fragSize.x * float(i), 0.0)).rgb * (gaussianKernels[x].kernels[y]);
    }
    imageStore(imgOutput, ivec2(coord), vec4(col, 1.0f));
}

void main()
{
    uint index = gl_GlobalInvocationID.x; 
    if (index >= viewportInfo.extent.z) return;
    vec2 coord = vec2(index % viewportInfo.extent.x, index / viewportInfo.extent.x);
    vec2 resolution = viewportInfo.extent.xy;
    vec2 uv = coord/resolution;
    vec2 fragSize = vec2(1)/resolution;
    
    vec3 col = texture(imgInput, uv).rgb  * gaussianKernels[0].kernels[0]; // center pixel
    for(int i = 1; i < blurInfo.blurRad; ++i)
    {
        int x = i / 16;
        int y = i % 16;
        col += texture(imgInput, uv + vec2(0.0, fragSize.y * float(i))).rgb * (gaussianKernels[x].kernels[y]);
        col += texture(imgInput, uv - vec2(0.0, fragSize.y * float(i))).rgb * (gaussianKernels[x].kernels[y]);
    }
    imageStore(imgOutput, ivec2(coord), vec4(1.0f));
}