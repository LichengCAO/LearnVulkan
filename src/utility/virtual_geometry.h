#pragma once
#define IDXTYPEWIDTH 32
#define REALTYPEWIDTH 32
#include <metis/include/metis.h>
#include "common.h"
#include "geometry.h"
#define VG_HIERARCHY_MAX_CHILD 4
#define VG_MAX_CLUSTER_GROUP_SIZE 16
#define VG_MAX_CLUSTER_INDEX 64

class VirtualGeometry
{
	// Tips:
	// Meshlets that grouped together are siblings;
	// meshlets that are combined together to form finer tiny meshlets are couples,
	// and these tiny meshlets are their children.
	// Parents have larger pieces(high LOD) compared to children(low LOD).
	// 
	// For each cluster: clusterError < groupError == parent's clusterError
	// There cannot be a gap between groupError and parent's clusterError, otherwise we may
	// encounter a problem when error threshold fall between groupError and parent's clusterError
	// 
	// Couples will share the same clusterError so that when clusterError is high enough,
	// all couples will decide to become smaller pieces(children);
	// when clusterError is low, they can either remain what they are or transfer to 
	// their parent meshlets with their siblings independently.
	// 
	// Siblings will have the same groupError so that when groupError is low enough,
	// they will all transfer to parent;
	// when groupError is high, they can either remain what they are or transfer to
	// child meshlets with their mates independently.

private:
	struct MyMeshlet
	{
		uint32_t lod = 0;
		
		// index pointing to error information of the meshlet
		Meshlet meshlet;
		
		// edges on the boundary, built with virtual indices of 2 ends
		std::set<std::pair<uint32_t, uint32_t>> boundaries;
		
		// index of adjacent meshlets in array -> number of shared edges
		std::unordered_map<uint32_t, uint32_t> adjacentWeight;
		
		// I call meshlets built from the same simplified triangle group as couples,
		// when converting to smaller pieces all couples must do the same
		// firstLove is index of the first node of the couple vector
		// since couples are stored consecutively I only store the loverCount addition to firstLove
		uint32_t firstLove;
		uint32_t loverCount;
		
		// one of parents whose LOD is higher(larger pieces),
		// that is, a meshlet built from simplified triangle which is generated by
		// this meshlet and its mates 
		uint32_t parent = ~0;
		
		// child meshlets whose LOD is lower, that is, the original meshlet of the group this meshlet built from, 
		// LOD0 meshlets don't have children
		std::vector<uint32_t> children;

		// Describes error of a meshlet(cluster)
		// use for culling and decide LOD
		glm::vec4 boundingSphere;	// xyz: position, w: radius
		float clusterError;			// all couples should have the same cluster error
		float groupError;			// all siblings should have the same group error
		uint32_t groupIndex;		// group index that shared by siblings
	};

	struct HierarchyNode
	{
		glm::vec4 bounding; // xyz: center | w: radius
		std::array<uint32_t, VG_HIERARCHY_MAX_CHILD> children = { ~0u, ~0u, ~0u, ~0u };
		float error;
		bool isClusterGroup = false;
		uint32_t groupLod = ~0u;
		uint32_t groupIndex = ~0u;
	};

public:
	class IntermediateNode
	{
	private:
		// layout
		// child0: 4 bytes   | child1 or clusterGroupIdx: 4 bytes | child2: 4 bytes | child3: 4 bytes -> [0-3]
		// center.x: 4 bytes | center.y: 4 bytes | center.z: 4 bytes | radius: 4 bytes -> [4-7]
		// error: 4 bytes    | padding: 12 bytes -> [8-11]
		std::array<uint32_t, 12> m_data; // data to copy to device

	public:
		// device side functions
		float GetError() const;
		void GetBoundingSphere(glm::vec3& outCenter, float& outRadius) const;
		void GetChildren(std::array<uint32_t, VG_HIERARCHY_MAX_CHILD>& outChildren) const;
		bool IsLeaf() const;
		bool ShouldTraverse(float inErrorThreshold) const;
		uint32_t GetClusterGroupDataIndex() const;

		// host side functions
		void GetDataToCopyToDevice(const void*& outSrcPtr, size_t& outSize);
	};

	class ClusterGroupData
	{
	private:
		// layout
		// clusterCount + vertexCount: 1 bytes + 3 bytes-> [0]
		// clusterData is 36 bytes each -> vertex offset 4 bytes | triangle offset 4 bytes | vertex count 4 bytes | triangle count 4 bytes | bounding 16 bytes | error 4 byptes
		// clusterData: 32 * 36 bytes -> [1 - 288]
		// vertex data: arbitrary size -> [289 - ... 289 + vertexCount];
		// triangle data: arbitrary size -> [... - end]
		std::vector<uint32_t> m_data;					// data to copy to device
		std::vector<uint32_t> m_childrenGroupDataIndex; // index of children ClusterGroupData in the array of ClusterGroupData

	private:
		uint32_t _GetClusterDataOffset(uint32_t inClusterId) const;

	public:
		// device side functions
		uint32_t GetClusterCount() const;
		uint32_t GetClusterVertexCount(uint32_t inClusterId) const;
		uint32_t GetClusterTriangleCount(uint32_t inClusterId) const;
		uint32_t GetClusterMeshVertex(uint32_t inClusterId, uint8_t inLocalIndex) const;
		void GetClusterTriangleIndices(
			uint32_t inClusterId, 
			uint32_t inTriangleIndex,
			uint8_t& outX,
			uint8_t& outY,
			uint8_t& outZ) const;
		void GetClusterBoundingSphere(
			uint32_t inClusterId,
			glm::vec3& outCenter,
			float& outRadius) const;
		float GetClusterError(uint32_t inClusterId) const;
		
		// host side functions
		void GetDataToCopyToDevice(const void*& outSrcPtr, size_t& outSize);
		uint32_t GetClusterChildGroupDataIndex(uint32_t inClusterId) const;
	};

private:
	const StaticMesh* m_pBaseMesh = nullptr;
	// std::vector<std::vector<Vertex>> m_lodVerts; seems won't work LOD0 meshlets are built from m_pBaseMesh, higher LOD meshlets are built from simplified triangles of lower LOD meshlets
	std::vector<std::vector<MyMeshlet>> m_meshlets;	// meshlets of different LODs
	std::vector<std::vector<std::vector<uint32_t>>> m_groups; // m_groups[LOD][groupId][meshletId]
	std::vector<HierarchyNode> m_hierarchy;

private:
	// Get vertices when the current LOD of vertices are incomplete
	//std::vector<Vertex>& _GetIncompleteVertices(uint32_t _lod);

	// Get vertices when the current LOD of vertices are complete
	const std::vector<Vertex>& _GetCompleteVertices(uint32_t _lod) const;

	// Add MyMeshlet objects, note it will also update children MyMeshlet's parent attribute
	// _lod: LOD of new meshlets
	// _error: error when simplifiy triangles to serve as the input to build new meshlets
	// _newMeshlets: meshlets built from simplified triangles
	// outChildren: index of meshlets from the group before triangle simplification
	// _pFirstIndex: output, if not nullptr, fill first index of newly added MyMeshlet objects
	// _pNumAdded: output, if not nullptr, fill number of MyMeshlet objects added
	void _AddMyMeshlet(
		uint32_t _lod,
		float _error,
		const std::vector<Meshlet>& _newMeshlets, 
		const std::vector<uint32_t>& _children,
		uint32_t* _pFirstIndex = nullptr,
		uint32_t* _pNumAdded = nullptr);

	// Fill structure used in METIS,
	// _xadj, _adjncy describes a meshlet connection graph,
	// _xadj[i] is the beginning index of _adjncy that describes the connection of meshlet i
	// note that _xadj is 1 more longer than meshlet list because it needs last element to 
	// identify the end of last connection information of the last meshlet
	// _adjwgt describes weight of each connection
	// _lod: LOD of meshlets of the graph
	void _PrepareMETIS(
		uint32_t _lod, 
		std::vector<idx_t>& _xadj, 
		std::vector<idx_t>& _adjncy, 
		std::vector<idx_t>& _adjwgt) const;

	// Find borders of meshlets of a specific LOD
	void _FindMeshletsBorder(uint32_t _lod);

	// Find how many edges shared by meshlet pair, fill adjacentWeight
	void _RecordMeshletConnections(uint32_t _lod);

	// Divide meshlets into groups based on edges they shader
	// _lod: lod of meshlets to group
	// _meshletGroups: array of indices of meshlets in a group
	// return if division is successful
	bool _DivideMeshletGroup(
		uint32_t _lod,
		uint32_t _groupCount,
		std::vector<std::vector<uint32_t>>& _meshletGroups) const;

	// Simplify triangles in meshlet groups, return error compared to the original mesh
	// _srcLod: LOD of meshlets to simplify, which is one level lower than result LOD
	// _meshletGroup: indices of meshlets in this lod that forms a group
	// _outIndex: indices that build simplified triangles
	float _SimplifyGroupTriangles(
		uint32_t _srcLod,
		const std::vector<uint32_t>& _meshletGroup,
		std::vector<uint32_t>& _outIndex) const;

	// Build new meshlets from simplified triangles in the group,
	// result will be added to the output, data already stored in output will be intact
	// _index: new set of index generated by _SimplifyGroupTriangle
	// _meshletData: local index points to the vertex in meshlet
	// _meshlet: output meshlet
	void _BuildMeshletFromGroup(
		const std::vector<Vertex>& _verts,
		const std::vector<uint32_t>& _index,
		std::vector<Meshlet>& _meshlet) const;

	// Split original mesh into meshlets of different LODs
	void _SplitMeshLODs();

	// Build hierarchy for culling, the number of children will not exceed 4 for each node
	// We first build hierarchy for each of the LODs
	// and then build hierarchy with root node of these LOD trees:
	//                  root
	//          /      /   \      \
	//     node0   node1   node2    node3
	//     / \      / \     / \       / \
	//   LOD0..    LOD4..   LOD8...   LOD12..
	void _BuildHierarchy();

	// Build hierarchy from _fullTree pointed by _bottomNodeIndex
	// Adds new nodes into _fullTree and return root node index of the added new hierarchy
	// _bottomNodeIndex: input, indices of the bottom level nodes, may be reordered for better
	//					 node grouping
	// _fullTree: output, new hierarchy nodes will be added to this
	uint32_t _BuildHierarchyHelper(
		std::vector<uint32_t>& _bottomNodeIndex,
		std::vector<HierarchyNode>& _fullTree) const;

	// Optimize node grouping in hierarchy to minimize the bounding sphere size of each group
	void _OptimizeHierarchyNodeGroups(
		const std::vector<HierarchyNode>& _fullTree,
		const std::array<uint32_t, VG_HIERARCHY_MAX_CHILD>& _groupSize,
		std::vector<uint32_t>& _nodeIndices) const;

	// Merge _node1 to _merged node
	// which involves:
	// enlarge _merged node's bounding sphere to include _node1
	// update parent error to the maximum of 2 nodes
	void _MergeHierarchyNode(const HierarchyNode& _node1, HierarchyNode& _merged) const;

public:
	void PresetStaticMesh(const StaticMesh& _original);
	
	void Init();

	void GetMeshletsAtLOD(uint32_t _lod, std::vector<Meshlet>& _meshlet) const;
};