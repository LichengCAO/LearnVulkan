#pragma once
#define IDXTYPEWIDTH 32
#define REALTYPEWIDTH 32
#include <metis/include/metis.h>
#include "common.h"
#include "geometry.h"
#define VG_HIERARCHY_MAX_CHILD 4

class VirtualGeometry
{
	// Tips:
	// Meshlets that grouped together are siblings;
	// meshlets that are combined together to form finer tiny meshlets are couples,
	// and these tiny meshlets are their children.
	// Parents have larger pieces(high LOD) compared to children(low LOD).
	// 
	// For each cluster: clusterError < groupError == parent's clusterError
	// There cannot be a gap between groupError and parent's clusterError, otherwise we may
	// encounter a problem when error threshold fall between groupError and parent's clusterError
	// 
	// Couples will share the same clusterError so that when clusterError is high enough,
	// all couples will decide to become smaller pieces(children);
	// when clusterError is low, they can either remain what they are or transfer to 
	// their parent meshlets with their siblings independently.
	// 
	// Siblings will have the same groupError so that when groupError is low enough,
	// they will all transfer to parent;
	// when groupError is high, they can either remain what they are or transfer to
	// child meshlets with their mates independently.

private:
	struct MyMeshlet
	{
		uint32_t lod = 0;
		
		// index pointing to error information of the meshlet
		uint32_t errorId = ~0;
		Meshlet meshlet;
		
		// edges on the boundary, built with virtual indices of 2 ends
		std::set<std::pair<uint32_t, uint32_t>> boundaries;
		
		// index of adjacent meshlets in array -> number of shared edges
		std::unordered_map<uint32_t, uint32_t> adjacentWeight;
		
		// I call meshlets built from the same simplified triangle group as couples,
		// when converting to smaller pieces all couples must do the same
		// firstLove is index of the first node of the couple vector
		// since couples are stored consecutively I only store the loverCount addition to firstLove
		uint32_t firstLove;
		uint32_t loverCount;
		
		// one of parents whose LOD is higher(larger pieces),
		// that is, a meshlet built from simplified triangle which is generated by
		// this meshlet and its mates 
		uint32_t parent = ~0;
		
		// child meshlets whose LOD is lower, that is, the original meshlet of the group this meshlet built from, 
		// LOD0 meshlets don't have children
		std::vector<uint32_t> children;

		// Describes error of a meshlet(cluster)
		// use for culling and decide LOD
		glm::vec4 boundingSphere;	// xyz: position, w: radius
		float clusterError;			// all siblings should have the same cluster error
		float groupError;			// all classmates should have the same group error
	};

public:
	// Use for upload page data
	struct GroupData
	{
		std::vector<Vertex> verts;
		std::vector<Meshlet> meshlets;
	};
	struct ClusterInfo
	{
		glm::vec4 bounding;
		float error;
		float parentError; // error for case when this cluster merge with others
		uint32_t groupID;
	};
	struct HierarchyNode
	{
		glm::vec4 bounding; // xyz: center | w: radius
		float parentError;	// consider this node only if threshold is smaller, otherwise, coarser parent nodes are already precise enough
		std::array<uint32_t, VG_HIERARCHY_MAX_CHILD> children = {~0u, ~0u, ~0u, ~0u};
		bool isClusterGroup = false;
	};

private:
	const StaticMesh* m_pBaseMesh = nullptr;
	std::vector<std::vector<Vertex>> m_lodVerts;	// LOD0 meshlets are built from m_pBaseMesh, higher LOD meshlets are built from simplified triangles of lower LOD meshlets
	std::vector<std::vector<MyMeshlet>> m_meshlets;	// meshlets of different LODs

private:
	// Get vertices when the current LOD of vertices are incomplete
	std::vector<Vertex>& _GetIncompleteVertices(uint32_t _lod);

	// Get vertices when the current LOD of vertices are complete
	const std::vector<Vertex>& _GetCompleteVertices(uint32_t _lod) const;

	// Add MyMeshlet objects, note it will also update children MyMeshlet's parent attribute
	// _lod: LOD of new meshlets
	// _error: error when simplifiy triangles to serve as the input to build new meshlets
	// _newMeshlets: meshlets built from simplified triangles
	// _children: index of meshlets from the group before triangle simplification
	// _pFirstIndex: output, if not nullptr, fill first index of newly added MyMeshlet objects
	// _pNumAdded: output, if not nullptr, fill number of MyMeshlet objects added
	void _AddMyMeshlet(
		uint32_t _lod,
		float _error,
		const std::vector<Meshlet>& _newMeshlets, 
		const std::vector<uint32_t>& _children,
		uint32_t* _pFirstIndex = nullptr,
		uint32_t* _pNumAdded = nullptr);

	// Fill structure used in METIS,
	// _xadj, _adjncy describes a meshlet connection graph,
	// _xadj[i] is the beginning index of _adjncy that describes the connection of meshlet i
	// note that _xadj is 1 more longer than meshlet list because it needs last element to 
	// identify the end of last connection information of the last meshlet
	// _adjwgt describes weight of each connection
	// _lod: LOD of meshlets of the graph
	void _PrepareMETIS(
		uint32_t _lod, 
		std::vector<idx_t>& _xadj, 
		std::vector<idx_t>& _adjncy, 
		std::vector<idx_t>& _adjwgt) const;

	// There may be some vertices that share same the position but store different information(normal, uv),
	// but in this case we only want to differentiate them based on their positions,
	// i.e. if 2 vertices are close enough, it should be treated as the same vertex,
	// so i create this function,
	// _realIndex: vertex index in Static Mesh
	// return virtual index used to compare if the 2 vertices are same
	uint32_t _GetVirtualIndex(uint32_t _realIndex) const;

	// Find borders of meshlets of a specific LOD
	void _FindMeshletsBorder(uint32_t _lod);

	// Find how many edges shared by meshlet pair, fill adjacentWeight
	void _RecordMeshletConnections(uint32_t _lod);

	// Divide meshlets into groups based on edges they shader
	// _lod: lod of meshlets to group
	// _meshletGroups: array of indices of meshlets in a group
	// return if division is successful
	bool _DivideMeshletGroup(
		uint32_t _lod,
		uint32_t _groupCount,
		std::vector<std::vector<uint32_t>>& _meshletGroups) const;

	// Simplify triangles in meshlet groups, return error compared to the original mesh
	// _srcLod: LOD of meshlets to simplify, which is one level lower than result LOD
	// _meshletGroup: indices of meshlets in this lod that forms a group
	// _outVerts: simplified vertices
	// _outIndex: indices that build simplified triangles
	float _SimplifyGroupTriangles(
		uint32_t _srcLod,
		const std::vector<uint32_t>& _meshletGroup,
		std::vector<Vertex>& _outVerts,
		std::vector<uint32_t>& _outIndex) const;

	// Build new meshlets from simplified triangles in the group,
	// result will be added to the output, data already stored in output will be intact
	// _index: new set of index generated by _SimplifyGroupTriangle
	// _meshletData: local index points to the vertex in meshlet
	// _meshlet: output meshlet
	void _BuildMeshletFromGroup(
		const std::vector<Vertex>& _verts,
		const std::vector<uint32_t>& _index,
		std::vector<Meshlet>& _meshlet) const;

	glm::vec4 _MergeBounds(const glm::vec4& _sphere1, const glm::vec4& _sphere2) const;

	// Split original mesh into meshlets of different LODs
	void _SplitMeshLODs();

	// Build hierarchy for culling, the number of children will not exceed 4 for each node
	// We first build hierarchy for each of the LODs
	// and then build hierarchy with root node of these LOD trees:
	//                  root
	//          /      /   \      \
	//     node0   node1   node2    node3
	//     / \      / \     / \       / \
	//   LOD0..    LOD4..   LOD8...   LOD12..
	void _BuildHierarchy();

	// Build hierarchy from _fullTree pointed by _bottomNodeIndex
	// Adds new nodes into _fullTree and return root node index of the added new hierarchy
	// _bottomNodeIndex: input, indices of the bottom level nodes, may be reordered for better
	//					 node grouping
	// _fullTree: output, new hierarchy nodes will be added to this
	uint32_t _BuildHierarchyHelper(
		std::vector<uint32_t>& _bottomNodeIndex,
		std::vector<HierarchyNode>& _fullTree) const;

	// Merge _node1 to _merged node
	// which involves:
	// enlarge _merged node's bounding sphere to include _node1
	// update parent error to the maximum of 2 nodes
	void _MergeHierarchyNode(const HierarchyNode& _node1, HierarchyNode& _merged) const;

public:
	void PresetStaticMesh(const StaticMesh& _original);
	
	void Init();
};