#pragma once
#define IDXTYPEWIDTH 32
#define REALTYPEWIDTH 32
#include <metis/include/metis.h>
#include "common.h"
#include "geometry.h"

class VirtualGeometry
{
private:
	struct MyMeshlet
	{
		Meshlet meshlet;
		std::set<std::pair<uint32_t, uint32_t>> boundaries;				// edges on the boundary, built with virtual indices of 2 ends
		std::unordered_map<uint32_t, uint32_t> adjacentWeight;	// index of adjacent meshlets in array -> number of shared edges
	};

private:
	const StaticMesh* m_pBaseMesh = nullptr;
	std::vector<MeshletDeviceData> m_meshletTable;		// meshlet table for different LODs
	std::vector<std::vector<MyMeshlet>> m_meshlets;		// meshlets of different LODs
	std::vector<uint32_t> m_realToVirtual;								// maps real index to virtual index based on vertex positions, virtual index points
																								// to a vertex in the static mesh that has the postion that differentiate this virtual index from others

private:
	// Build m_realToVirtual for the m_pBaseMesh
	void _BuildVirtualIndexMap();

	// Fill structure used in METIS,
	// _xadj, _adjncy describes a meshlet connection graph,
	// _xadj[i] is the beginning index of _adjncy that describes the connection of meshlet i
	// note that _xadj is 1 more lengther than meshlet list because it needs last element to 
	// identify the end of last connection information of the last meshlet
	// _adjwgt describes weight of each connection
	// _lod: LOD of meshlets of the graph
	void _PrepareMETIS(
		uint32_t _lod, 
		std::vector<idx_t>& _xadj, 
		std::vector<idx_t>& _adjncy, 
		std::vector<idx_t>& _adjwgt) const;

	// There may be some vertices that share same the position but store different information(normal, uv),
	// but in this case we only want to differentiate them based on their positions,
	// i.e. if 2 vertices are close enough, it should be treated as the same vertex,
	// so i create this function,
	// _realIndex: vertex index in Static Mesh
	// return virtual index used to compare if the 2 vertices are same
	uint32_t _GetVirtualIndex(uint32_t _realIndex) const;

	// Find boundary of the meshlet, fill boundaries
	void _FindMeshletBoundary(
		const MeshletDeviceData& _meshletData,
		const Meshlet& _meshlet, 
		std::set<std::pair<uint32_t, uint32_t>>& _boundaries) const;

	// Find how many edges shared by meshlet pair, fill adjacentWeight
	void _RecordMeshletConnections(uint32_t _lod);

	// Divide meshlets into groups based on edges they shader
	// _lod: lod of meshlets to group
	// _meshletGroups: array of indices of meshlets in a group
	// return if division is successful
	bool _DivideMeshletGroup(
		uint32_t _lod, 
		std::vector<std::vector<uint32_t>>& _meshletGroups);

	// Simplify triangles in meshlet groups, return error compared to the original mesh
	// _lod: lod of meshlets to group
	// _meshletGroup: indices of meshlets in a group
	// _outIndex: indices that build simplified triangles
	float _SimplifyGroupTriangles(
		uint32_t _lod,
		const std::vector<uint32_t>& _meshletGroup,
		std::vector<uint32_t>& _outIndex);

	// Build new meshlets from simplified triangles in the group,
	// result will be added to the output, data already stored in output will be intact
	// _index: new set of index generated by _SimplifyGroupTriangle
	// _meshletData: local index points to the vertex in meshlet
	// _meshlet: output meshlet
	void _BuildMeshletFromGroup(
		const std::vector<uint32_t>& _index,
		MeshletDeviceData& _meshletData,
		std::vector<Meshlet>& _meshlet);

public:
	void PresetStaticMesh(const StaticMesh& _original);
	
	void Init();
};